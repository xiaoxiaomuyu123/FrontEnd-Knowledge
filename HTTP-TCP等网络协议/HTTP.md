# 一、

目的，明白在地址栏输入 url 到得到页面的过程是什么？

## 一. 网络协议分层

应用层（HTTP, FTP），传输层(TCP,UDP)，网络层，数据链路层，物理层

## 二. http 发展历史

#### 2.1 http0.9

- 只有一个 get 方法；
- 没有 header 等描述数据的信息；
- 服务器发送完毕就关闭 tcp 连接。也就是说每发送一次 http 请求，就要建立一次 tcp 连接，开销较大。

#### 2.2 http 1.0

- 增加了很多命令：post，put，head
- 增加了状态码和头部信息内容
- 多字符集支持，多部分发送，权限，缓存等

- 依然有这个缺点：服务器发送完毕就关闭 tcp 连接。也就是说每发送一次 http 请求，就要建立一次 tcp 连接，开销较大


#### 2.3 http1.1

- 支持了持久连接：一个 tcp 连接支持多个 http 请求。在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
- pipeline：一个 tcp 连接支持多个 http 请求，发送多个 http 请求的时候，不管服务器对前一个http请求有没有做出应答，都可以发送后一个请求。但是服务器接收到很多http请求的时候，是按照每个 http 请求的顺序做出应答的。也就是说，如果前一个 http 请求的处理时间非常慢，后一个 http 请求处理的时间非常快，后一个 http 请求的应答也必须等前一个 http 请求处理完才能处理。
- 增加了 host 和其他，命令。增加了 host 好处是，我们在同一个物理服务器上可以部署不同的 web 服务。

#### 2.4 http2

目前还没有普及

- 所有数据以二进制的形式传输。http1.1 数据以字符串的形式传输
- 针对 http 1.1 的 pipeline 进行优化。HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。http 1.1 发送并行，接收串行。某个请求的响应时间过长，会影响后面的请求响应，出现线头阻塞。
- 头信息压缩：这样数据体积小了，在网络上传输就会更快。
- 服务器推送：当我们对支持 HTTP2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。 

## 三. tcp 三次握手

### 为什么需要三次握手？   

如果采取两次握手，相当于第二次握手结束便建立连接，如果发送SYN的一方不想连接了，也不会有反馈，另一方却一直在等待，浪费了时间。当然可以采取4次甚至N次握手，但是有必要吗？建立连接的时间太长，效果也会大打折扣。所以3次只是折中方案，保证了可靠性，又节俭了建立连接的时间。

## 四. URI URL URN

- URI

- URL

- URN

## 五. http 报文

- 请求报文：请求行，请求头部，请求体    
请求行：请求方法，url，http 版本

- 响应报文：响应行，响应头部，响应体   
响应行：http 版本，状态码，状态说明

#### 1. http 常用方法
- get
- post
- head
- put
- delete
- options

#### 2. http 状态码

-
-
-
-
-
-
-
-
-
-
- 

#### 3. post 和 get 区别

- get  
    - 把数据放在 url 中，不安全，也有数据大小的限制，适合传送小量的数据。，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。  
    
    - 侧重从服务器中取数据。由于GET请求一般是用于资源信息的获取而非修改，换言之，GET请求一般不会产生副作用，它仅仅是获取资源信息，就像数据库查询一样，不会改变数据，不会影响资源的状态。所以，GET请求不一般会改变服务器状态。幂等意味着对于同一个URL的多个请求应该返回同样的结果。
    
    - get 请求可以缓存



- post
    
    - 数据放在请求体中传送，安全，适合传送较大的数据。    
    
    - 侧重把数据发送到服务器，跟新后台数据库中的数据
    
    - post 请求不能缓存
   
然而，从传输的角度来说，get 和 post 都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。要想安全传输，就只有加密，也就是 HTTPS

#### 4. http 和 https 的区别

#### http 缺点

加密处理防止被窃听：加密的对象可以有这么几个
通信的加密：    
- 一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL。    

- 内容的加密：还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。


不验证通信方的身份就可能遭遇伪装：任何人都可发起请求在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。  

- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。   

- 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。    

- 无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。    

- 无法判定请求是来自何方、出自谁手。
即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。


### http缺点：   
  
- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

### https

HTTP 加上加密处理和认证以及完整性保护后即是HTTPS

- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。   
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。   
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。   
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
    

#### 5. 什么时候用 http，什么时候用 https

和上面的一样


#### 6 websocket 和 http 区别

- http    
http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。

- websocket   
WebSocket他是为了解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮训问题而生的，他实现了多路复用，他是全双工通信。在webSocket协议下客服端和浏览器可以同时发送信息。   
建立了WenSocket之后服务器不必在浏览器发送request请求之后才能发送信息到浏览器。这时的服务器已有主动权想什么时候发就可以发送信息到服务器。而且信息当中不必在带有head的部分信息了与http的长链接通信来说，这种方式，不仅能降低服务器的压力。而且信息当中也减少了部分多余的信息。  
WebSocket优势： 浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息。同时，服务器与客户端之间交换的头信息很小


## 六、http 缓存机制

http缓存主要针如css，js，图片等更新频率不大的静态文件。

常用头部字段：

- cache-ctrol：  
 
    该字段的取值

    - public
    - privite：仅发起请求的浏览器可以缓存
    - s-max-age：设置代理服务器的缓存时间
    - max-age
    - no-cache
    - no-store
    - max-stale：即便缓存已经过期了，只要在这个设置时间之内是可以读取过期的文件。这个头部字段是服务器端设置的。
    - must-revalidate：
    - proxy-revalidate：
    - no-transform：告诉缓存服务器不要随意改动从服务器请求的内容，比如不要压缩。
    
        
当服务器设置响应头部字段 `"cache-contorl" ： "max-age=60*60*24" ` 意思是在一天之内进行缓存。这本来是一个前端优化，提升用户体验。但是设置了这个值以后，如果在这一天之内服务器的资源修改了，浏览器也不会更新资源，依旧会使用本地缓存，这是我们不愿意看到的。解决方案就是：服务器在后端打包文件的时候，对于静态资源的文件名设置成文件名加上一个 hash 值。这个 hash 值是根据文件内容生成的唯一值，当内容变化时，hash 也会变化。这样就可以控制 html 文件中 script 中 src 属性的值，当 scr 属性值变化的时候，也就是路径发生变化的时候，页面请求的就是一个新的资源，而不是原来的资源，就不会使用缓存的资源。这样就可以根据这个值变不变化来决定是否要用缓存文件。这是业内普遍的解决方案。

- Last-Modified：上次修改的时间。配合 If-Modified-Since 和 If-Unmodified-Since 使用。

- Etag：通过数据签名，对资源的内容产生一个唯一的签名。一般是对资源的内容进行哈希计算。与 If-Match 和 If-None-Match 配套使用。


## 七、cookie 和 session

- cokkie   
cookie 是服务器在返回消息给浏览器的时候，通过 Set-Cookie 来保存到浏览器中的一些内容，设置多个 key value 值用数组。下一次 htttp 请求的时候，会自动带上 cookie。它是以键值对的形式进行保存的，可以设置很多个。   
cookie的属性：
    - max-age 和 Expires 用来设置 cookie 的过期时间。如果没有设置 max-age 或者 Expires，那么刷新页面 cookie 就没有了。再过有效期内，下一次请求会带上这个 cookie，超过这个有效期，下一次请求就不会带上这个 cookie
    - Secure 用来设置 只有在 https 请求的时候才会带上 cookie。http 请求的时候不会带上 cookie。
    - 设置了 httpOnly，cookie 就无法通过 javascript 里面的 document.cookie 来访问 cookie 的内容。这样做可以防止 XSS 攻击。出于安全考虑，要禁止重要的数据被 js 脚本访问    
    - 同一个域名下，cookie 可以相互访问，不同域名下，不能相互访问。不同域名下也不能设置 cookie。在一个一级域名下设置 cookie， 通过  `domain="text.com"` ，那么 text.com 一级域名下的子域名可以访问到 cookie。


# 八、http 长连接


# 九、数据协商

- 请求：

    - Accept：指定客户器想要的数据类型，也就是浏览器的可以接受可以展示的数据
    - Accept-encoding：数据的编码方式
    - Accept-language：支持展示的语言
    - User-Agent：浏览器的相关信息
    
- 响应

    - Content-Type： 返回的数据格式
    - Content-encodeing：服务端用的编码方式
    - Content-language：
    
# 十、redirect  

302 和 301 的区别：场景，将 url 重定向到 url2

- 301：永久重定向，设置了 301 之后，浏览器端输入 url1，直接访问重定向的路径 url2。因为是永久重定向，所以 301 会使得浏览器尽可能唱的时间去缓存。要慎重去用。一旦设置了 301，除非用户清空缓存，否则一只会从缓存里面加载。
- 302：临时重定向，设置了 302 之后，浏览器先访问 url1，再重定向到 url2.

# 十一、Content-Security-Polity： 内容安全策略  

# 十二、Nginx   

- 安装