## 1. 什么是同源策略？
- 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
- 定义：两个页面的协议，端口（如果有指定）和主机（域名）都相同，则两个页面具有相同的源。网址中没有写端口，http 就默认 80，https 默认是 443。

## 2. 非同源会怎么样？
- cookie，localStorage，indexDB 无法读取
- DOM 无法获得
- AJAX 请求无法发送

## 3. 为什么需要同源策略？
如果没有同源策略，网站就有可能会遭到 CSRF 和 XSS 攻击。
### 3.1 CSRF 跨站请求伪造
- **理解什么是 CSRF:**  
攻击者盗用了用户的身份，以用户的名义向网站发送了恶意请求。比如：以用户的名义发送邮件，发送消息，转出资金，购买商品等，造成个人隐私泄露，危害财产安全。
- **CSRF 的简单原理：**   
图片：

- **CSRF 的防御：**   
如果存在同源策略，由于主机不一样或者端口号不一样，B 无法取得 C 的 cookie 信息来伪装成 C，也就不能以 C 的名义向 A 发送请求了。   
  
  CSRF 可以从客户端和服务器端两个方面进行防御，但一般服务器段进行防御效果会好一些。   
  - 服务器端的防御：
  1. 验证 HTTP Referer 字段：  
  根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。Referer标识当前请求的来源页面，浏览器访问时除了自动带上Cookie还会自动带上Referer，所以服务端可以检测Referer头是否本网站页面来决定是否响应请求。因此，要防御 CSRF 攻击，网站只需要对于每一个请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。  
  2. 在请求地址中添加 token 并验证：   
  在 url 中新增一个 token 值，这个 token 值是随机的、不可预测的:https://host/path/delete?username=abc&item=123456&token=[random(seed)]。token值为用户和服务器所有，这个值可以放在用户的session中，或者浏览器的cookie中。有token值时，用户提交请求，服务器只需要验证表单中的token与用户session(或cookie)中的token值是否一致即可。由于攻击者无法再构造出一个完整的URL，那么CSRF攻击就无法实施。
   - 浏览器端的防御：
   还未找到资料。
### 3.2 XSS 跨站脚本攻击
- 理解什么是 XSS    
指攻击者在网页中嵌入客户端脚本(例如JavaScript), 当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.  比如获取用户的Cookie，导航到恶意网站,携带木马等。
- XSS 的原理   
XSS之所以会发生， 是因为用户输入的数据变成了代码。
- XSS 的防御    
对用户输入的数据进行HTML Encode处理。 将其中的"中括号"， “单引号”，“引号” 之类的特殊字符进行编码。
## 4. 跨域  
针对非同源产生的三种限制结果，    
- cookie，localStorage，indexDB 无法读取
- DOM 无法获得
- AJAX 请求无法发送   
    
产生了针对这三种限制结果的跨域方案：
### 4.1 针对由于同源策略产生的 cookie，localStorage，indexDB 无法读取的解决方案：
#### 1. 通过设置相同的`document.domain`跨域获取 cookie：  
只有同源的网页才能共享 cookie，但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。   
    
举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。`document.domain = 'example.com';` 现在 AB 两个网页可以共享 cookie 了。   
   
但要注意，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API

#### 2. 服务器指定 cookie 所属的域名为一级域名
服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。`Set-Cookie: key=value; domain=.example.com; path=/` ，这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。

### 4.2 针对由于同源策略使得不同源之间的 DOM 无法获取的解决方案：
典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。

### 4.3 针对由于同源策略 AJAX 无法跨域请求数据的解决方案：
有四种解决方案：   
- 服务器代理
- JSONP
- WebSocket
- CORS

#### 1. 服务器代理

#### 2. JSONP
- 概述：  
用 `<script>` 标签来完成获取数据的工作。script 是用来包裹代码的，并且 script 的 src 属性能够跨域请求资源，那么我们就可以把需要的数据放在 script 标签中，完成跨域的数据传输。
- 网页通过添加一个`<script>`元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。具体过程可以参看 headfirst of html5 P278、P279。
- 优点是：老浏览器全部支持，服务器改造小。   
缺点是：JSONP 只能发 GET 请求。想要发 POST 请求，可以用 

#### 3. WebSocket
WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。   
浏览器发出的WebSocket请求的头信息有一个字段是 Origin，表示该请求的请求源（origin），即发自哪个域名。   
正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出回应。      
WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
#### 4. CORS
CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨域 AJAX 请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。    

   
