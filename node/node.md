## node 学习笔记

#### 一、什么是 node

node 是 JS 的一个运行环境，提供了服务器操作级别的 API，例如：文章读写，网络服务的构建，网络通信，http 服务器等等。
#### 二、node.js 的特点

事件驱动，非阻塞 I/O 模型，轻量和高效。  
阻塞I/O：I/O 时进程休眠，等待 I/O 完成后进行下一步。非阻塞 I/O：I/O 时函数立即返回，进程不等待结果，直接进行运行后面程序的代码。
事件驱动：用来做各种各样的通知，例如只有用户点击的时，才会通知主进程完成相应的事件操作。这里在 node 中就是 I/O 操作结束后就会通知主进程。内部实现是观察者模式。

#### 三、前端为什么偏爱 node

1. 前端职责变大，统一开发体验
2. 处理高并发，I/O 密集型场景有优势。web 开发就是这样的场景。

此时需要理解 cpu 密集和 I/O 密集。如果一个程序大量时间用于做计算，逻辑运算等 cpu 动作，比如：压缩，解压，加密，解密，就称之为 cpu 密集。如果程序大部分时间在做存取数据，网络设备的读取操作，如：文件操作，http 相关的网络操作，数据库，就称之为 I/O 密集。web 中常见的操作：静态资源读取，数据库操作，反复读取数据，渲染页面，根据数据生成页面，所以 web 是一个典型的 I/O 密集型场景了。

再来理解高并发。通用高并发的解决之道，第一是增加机器数，当流量变大的时候，通过负载均衡让不同的服务器处理 web 请求，但是机器越来越多，不方便，成本也高了。第二是增加每台机器的 CPU 数（多核），这样运行能力就增强了。

先理解 进程：电脑对应的音乐播放器播放的时候，浏览器进行浏览网页的活动，就是不同的进程。单核 CPU 也是可以一边听音乐，一边上网的。单核计算机会在非常快的速度做切换，一会进行音乐，一会进行上网，但在人看来，就是同时的了。在 web 场景中，每来一个请求，服务器就开启一个进程，来处理这个用户的请求，CPU 就算一下这个用户想干什么，cpu 分析很快，但是大部分时间都是用于 I/O 操作。如果是阻塞型 I/O 操作，这个进程被 I/O 操作阻塞住了，必须等待 I/O 操作完成才能进行下一步操作，那么再来别的请求，我们就得再重新开启另外一个进程来处理别的请求。但是一台机器开启进程的数目是有限的，一旦访问量变大，进程不够用了，就只能通过不断地增加机器数目来解决巨大的请求数量。但是呢，在 web 场景中 CPU 运算的时间远远小于 I/O 操作，I/O 操作占据了大部分时间，在这个进程进行 I/O 操作的时候，这个进程使用的 CPU 资源就只能空转等着 I/O 操作完成，但是 web 中的其他操作还需要 CPU 做计算呢，这个时候 CPU 只能在这里空转等待 I/O 操作的结果，这时 CPU 的性能就浪费了。而 node 就焊好的解决了这个 cpu 浪费的问题。在进行 I/O 操作的时候，node 并不等着 I/O 操作的结果，而是继续执行后面的代码，等 I/O 操作完成后，通知主进程，再进行怎么处理结果的操作。

线程：一个进程有多个线程。如听音乐是一个进程，cpu 分配给这个音乐播放器一部分资源，那么音乐播放器里面还有一些其他功能就是不同的线程，每个线程只能占用这个音乐播放器申请的 cpu 相应的资源。

node 只开一个进程，一个进程里面只有一个线程。单线程只是针对主进程，但是执行 I/O 操作会进行操作系统的底层的多线程调度，也就是说，node 只是通过线程发起一个 I/O 请求，但是在执行 I/O 操作的时候，那就是操作系统底层干的事情了，它向调度什么就调度什么，和 node 的进程线程没有关系。node 只是进行单进程的监听，操作系统处理好 I/O，告诉 node 处理好了， I/O 再针对结果执行相应的操作。node 再等待结果的同时还会继续做其他的事情，不浪费 cpu 的资源。

注意当电脑是 多核的时候，node 也会完全利用上这台机器的多个cpu，开启多个线程。

node 性能好的前提：web 场景，I/O 密集，高并发。如果是 CPU 密集，node 性能就不好了。

3. 公司中常用的 node 的场景
1. web server
2. 本地代码的构建。前端的代码异常复杂了，会有很多工具，如 webpack，都是用 node 写的，虽然性能不是最佳，有语法优势。
3. 实用工具开发

官网：nodejs.org


#### 四、node 模块系统，也就是 commonJS 模块系统

node 中没有全局作用域，只有模块作用域。每个模块的变量都不会污染到其他模块。即便在 a.js 里面利用 require 加载了 b.js，我们也不能通过 b 来调用 a 里面的函数和变量，a 也不能调用 b 里面的函数和变量。但是如何让 a.js 的代码访问到 b.js 呢，也就是如何实现模块之间的通信呢？要使用 每个模块的默认对象 exports 。要把 b.js 需要暴露给外面的函数和变量绑定到这个 export 对象上，作为 export 的属性和方法被外界调用。export.变量 = 值
最终 return 的是 module.export

require 规则：
1. / 表示绝对路径    ./ 表示当前文件所在路径
2. 支持 js json node 这三个扩展名，如果调用的时候没有写扩展名，会根据这三个扩展名依次尝试
3. 不写路径会被认为是 bulid-in 模块，或者是安装在各级目录内 node_modules 内的第三方模块。

require 特性：
1. module 被加载的时候就会立即执行，加载之后会被缓存。只加载一次，第二次加载的时候直接用放在内存中的结果了
2. 要避免模块之间循环依赖，因为循环依赖之后，只执行已经输出的部分，还未执行的部分不会输出。

#### 五、断点调试

1. 在 命令行输入 node --inspect-brk 文件名
2. 打开 chrom，在开发者工具中打开 node 绿色小图标，进入调试环境
3. 参考 http://www.ruanyifeng.com/blog/2018/03/node-debugger.html

#### 六、如何设置接口

- 确定好接口的 url
- 确定请求的方式，是 post 还是 get
- 设计接口返回的数据格式，成功的时候返回什么，失败的时候返回什么
- 接收的参数都有什么
